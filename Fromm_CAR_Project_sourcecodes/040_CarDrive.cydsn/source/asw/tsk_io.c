/*
 * Filename: tsk_io.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: This task will contain all IO operations, e.g. remote, engine,...
 * events: ev_eventout_onData|ev_protocolrx_onError|ev_tick_1ms|ev_xbee_rx
 * mode: Cyclic and Event
 * name: tsk_io
 * shortname: io
 * signalpoolsRO: sp_common
 * signalpoolsRW: sp_common
 * tickEvent: ev_tick_1ms
 * timertickperiod: 1
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "tsk_io.h"



/* USER CODE START TSK_IO_INCLUDE */
#include "sc_protocol_type.h"
/* USER CODE END TSK_IO_INCLUDE */

#include "swc_engine.h"
#include "swc_remote.h"



/* USER CODE START TSK_IO_USERDEFINITIONS */

/* USER CODE END TSK_IO_USERDEFINITIONS */

/*******************************************************************************
 * Runnable Tables from Activation Engine
 *******************************************************************************/

/* Cyclic Table */

const RTE_cyclicTable_t RTE_cyclicActivationTable_tsk_io[] = {
	{ ENGINE_setspeed_run, 100 },	//Engine controller runnable
	{ REMOTE_error_run, 100 },	//Error handler for Remote. Triggers on invalid data and wrong age. Will call central error handler as escalation.
};
const uint16_t RTE_cyclicActivation_tsk_io_size = sizeof (RTE_cyclicActivationTable_tsk_io) / sizeof(RTE_cyclicTable_t); 

/* Event Table */
const RTE_eventTable_t RTE_eventActivationTable_tsk_io[] = {
    { REMOTE_transmit_run, ev_eventout_onData },  //Receives outgoing event and creates and XBee protocol
    { REMOTE_receive_run, ev_xbee_rx },  //Receive an incoming protocol and translates the content into joystick or event signal
    { REMOTE_error_run, ev_protocolrx_onError },  //Error handler for Remote. Triggers on invalid data and wrong age. Will call central error handler as escalation.
}; 
const uint16_t RTE_eventActivation_tsk_io_size = sizeof (RTE_eventActivationTable_tsk_io) / sizeof(RTE_eventTable_t);

/*******************************************************************************
 * Task Body
 *******************************************************************************/


/*
 * description: This task will contain all IO operations, e.g. remote, engine,...
 * events: ev_eventout_onData|ev_protocolrx_onError|ev_tick_1ms|ev_xbee_rx
 * mode: Cyclic and Event
 * name: tsk_io
 * shortname: io
 * signalpoolsRO: sp_common
 * signalpoolsRW: sp_common
 * tickEvent: ev_tick_1ms
 * timertickperiod: 1
 */
TASK(tsk_io)
{
	/* ticktime of the task */
	static uint32_t ticktime = 0;
	
    EventMaskType ev = 0;
    
    while(1)
    {
        //Wait, read and clear the event
        WaitEvent(ev_eventout_onData|ev_protocolrx_onError|ev_tick_1ms|ev_xbee_rx);
        GetEvent(tsk_io,&ev);
        ClearEvent(ev);
    
		/* USER CODE START TSK_IO_TASKBOBY_PRE */

		/* USER CODE END TSK_IO_TASKBODY_PRE */
        
        if (ev & ev_tick_1ms){
            //Process Cyclic table on tick
            RTE_ProcessCyclicTable(RTE_cyclicActivationTable_tsk_io, RTE_cyclicActivation_tsk_io_size, ticktime);

			ticktime += 1;
			if (ticktime > 0xFFFFFF00) ticktime = 0;

		};
		
		//Process data driven events
		RTE_ProcessEventTable(RTE_eventActivationTable_tsk_io, RTE_eventActivation_tsk_io_size, ev);
		
		/* USER CODE START TSK_IO_TASKBODY_POST */

	/* USER CODE END TSK_IO_TASKBODY_POST */

        
    }
}


/*******************************************************************************
 * Interrupt Service Routines
 *******************************************************************************/

/* USER CODE START TSK_IO_ISR */

ISR(Xbee_rx_isr)
{
    //Read data from the driver
    uint16_t error_data = XBee_GetByte();
    uint8_t data = (uint8_t)error_data;
    uint8_t error = (uint8_t)(error_data >> 8);
    
    //Required for EOP sequence
    static uint8_t prevChar = 0;

    //Check for transmission errors
    if (XBee_RX_STS_PAR_ERROR & error || 
        XBee_RX_STS_STOP_ERROR & error ||
        XBee_RX_STS_OVERRUN & error)
    {
        //Ignore data and unsync protocol in case of error
        PROTOCOL_UnsyncProtocol();
        return;
    }
    
    //Synchronise on first run
    if (FALSE == PROTOCOL_SyncProtocol(data))
    {
        //ignore data and wait until protocol is synced
        return;
    }

    
    RC_t result = Ringbuffer_Put(&PROTOCOL_rx_buffer, data);
    if (PROTOCOL_EOP1_VALUE == prevChar && PROTOCOL_EOP2_VALUE == data)
    {
        //Complete protocol
        SetEvent(tsk_io, ev_xbee_rx);
        prevChar = 0;
        
    }
    else
    {
        prevChar = data;
    }
}

/* USER CODE END TSK_IO_ISR */

