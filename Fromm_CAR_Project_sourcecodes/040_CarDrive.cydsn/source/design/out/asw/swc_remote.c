/*
 * Filename: swc_remote.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: Remote control, reading / sending XBee protocols
 * name: swc_remote
 * shortname: remote
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "swc_remote.h"



/* USER CODE START SWC_REMOTE_INCLUDE */
#include "logging.h"
/* USER CODE END SWC_REMOTE_INCLUDE */


#include "sp_common.h"

/* USER CODE START SWC_REMOTE_USERDEFINITIONS */

/* USER CODE END SWC_REMOTE_USERDEFINITIONS */



/*
 * component: swc_remote
 * cycletime: 0
 * description: Receives outgoing event and creates and XBee protocol
 * events: ev_eventout_onData
 * name: REMOTE_transmit_run
 * shortname: transmit
 * signalIN: so_eventOut
 * signalOUT: so_protocolTx
 * task: tsk_io
 */
void REMOTE_transmit_run(RTE_event ev){
	
	/* USER CODE START REMOTE_transmit_run */

    /* USER CODE END REMOTE_transmit_run */
}

/*
 * component: swc_remote
 * cycletime: 0
 * description: Receive an incoming protocol and translates the content into joystick or event signal
 * events: ev_xbee_rx
 * name: REMOTE_receive_run
 * shortname: receive
 * signalIN: so_protocolRx
 * signalOUT: so_joystick|so_eventIn
 * task: tsk_io
 */
void REMOTE_receive_run(RTE_event ev){
	
	/* USER CODE START REMOTE_receive_run */
    
    //Create some locals for the signal data payload
    SC_PROTOCOL_data_t protocol = SC_PROTOCOL_INIT_DATA;
    SC_JOYSTICK_data_t joystick = SC_JOYSTICK_INIT_DATA;
    SC_EVENT_IN_data_t event = SC_EVENT_IN_INIT_DATA;
    
    //Read in the protocol from the ringbuffer
    RC_t result = RTE_SC_PROTOCOL_pullPort(&SO_PROTOCOLRX_signal);
    
    //In case of an error, the error runnable will be called.
    //But we should not process the data in this case, so let's check it
    //We could also check the signal validity status, but this will provide the same information
    
    if (RC_SUCCESS == result)
    {
        //We have a valid protocol, so let's check the content
        protocol = RTE_SC_PROTOCOL_get(&SO_PROTOCOLRX_signal);

        //LOG_I("rx","mid: %i fid : %i", protocol.m_fid, protocol.m_mid);
        
        //============================= Translate FID into abstract event for connection state machine ================================================

		if (PROT_MID__CONNECT == protocol.m_mid) {

			switch (protocol.m_fid) {
			case PROT_FID_Present:
				event.m_ev = EV_IN_Present;
				break;
			case PROT_FID_Connect:
				event.m_ev = EV_IN_Connect;
				break;
			case PROT_FID_Disconnect:
				event.m_ev = EV_IN_Disconnect;
				break;
			case PROT_FID_Stop:
				event.m_ev = EV_IN_Stop;
				break;
			case PROT_FID_Reset:
				event.m_ev = EV_IN_Reset;
				break;
			case PROT_FID_Feature:
				event.m_ev = EV_IN_RequestFeature;
				break;
			case PROT_FID_Activate: //Here, payload is required
				event.m_ev = EV_IN_ActivateFeature;
				event.m_lengthPayload = protocol.m_length;
				for (uint8_t i = 0; i < protocol.m_length; i++) {
					event.m_payload[i] = protocol.m_payload[i];
				}
				break;
			case PROT_FID_Brake: /* ignored */

			default:
				event.m_ev = EV_IN_NoEvent;
				break;
			}

			//Update signal
			if (event.m_ev != EV_IN_NoEvent) {
				result = RTE_SC_EVENT_IN_set(&SO_EVENTIN_signal, event);
			}
		}

		//============================= Translate Joystick Data  ================================================

		/**
		 *
		 *		Protocol Item 	Content 		Range
		 *		MID 			'J'
		 *		FID 			'J'
		 * 		Payload[0] 		Joystick x 		-100..100
		 * 		Payload[1] 		Joystick y 		-100..100
		 *		Payload[3] opt 	Joystick phi 	-100..100
		 *		Payload[4] opt 	Emergency Brake 0..1
		 *		Payload[5] opt 	Normal Brake 	0..1
		 *
		 * Please check https://web.eit.h-da.de/studentcar_trac/wiki/car3_uart_remote for a description of the structure
		 *
		 */

		else if (PROT_MID__JOYSTICK == protocol.m_mid) {

			switch (protocol.m_fid) {
			case PROT_FID_Joystick:
				joystick.m_x = (sint8_t) protocol.m_payload[0];
				joystick.m_y = (sint8_t) protocol.m_payload[1];

				//The next protocol parts are optional, therefore the length of the transferred needs to be checked
				if (protocol.m_length > 2)	joystick.m_z = (sint8_t) protocol.m_payload[2];
				if (protocol.m_length > 3)	joystick.m_emergencyStop = protocol.m_payload[3];
				if (protocol.m_length > 4)	joystick.m_normalStop = protocol.m_payload[4];

			default: /* Todo error handling */ break;
			}

			result = RTE_SC_EVENT_IN_set(&SO_EVENTIN_signal, event);

		}
	} else {
		//Todo some decent error handling
		//At the moment - simply set the joystick to NULL position and to not transfer any events

		joystick = SC_JOYSTICK_INIT_DATA;
		result = RTE_SC_EVENT_IN_set(&SO_EVENTIN_signal, event);

		return;
	}


    /* USER CODE END REMOTE_receive_run */
}

/*
 * component: swc_remote
 * cycletime: 100
 * description: Error handler for Remote. Triggers on invalid data and wrong age. Will call central error handler as escalation.
 * events: ev_protocolrx_onError
 * name: REMOTE_error_run
 * shortname: error
 * signalIN: so_protocolRx|so_protocolTx
 * signalOUT: 
 * task: tsk_io
 */
void REMOTE_error_run(RTE_event ev){
	
	/* USER CODE START REMOTE_error_run */

    /* USER CODE END REMOTE_error_run */
}

/* USER CODE START SWC_REMOTE_FUNCTIONS */

/* USER CODE END SWC_REMOTE_FUNCTIONS */

