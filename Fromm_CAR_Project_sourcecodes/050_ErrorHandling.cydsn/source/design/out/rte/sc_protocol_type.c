/*
 * Filename: sc_protocol_type.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: XBee protocol from remote
 * name: sc_protocol
 * shortname: protocol
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "sc_protocol_type.h"



/* USER CODE START SC_PROTOCOL_INCLUDE */

#include "logging.h"
#include "carconfig.h"

/* USER CODE END SC_PROTOCOL_INCLUDE */




/* USER CODE START SC_PROTOCOL_USERDEFINITIONS */

/* ========================================================================================== */

/* Local protocol defines */
#define PROTOCOL_CRC_LENGTH  		1
#define PROTOCOL_FID_LENGTH			1
#define PROTOCOL_JOYSTICK_DATA_LENGTH 5 // x-axis, y-axis, rz-axis,	button 1, button 2


    
/* Compute the expected length of a package if the length is variable.*/
#define COMPUTE_EXPECTED_LENGTH(payload) (PROTOCOL_BASIC_LENGTH + (payload) )

/**
 * The Ringbuffer object 
 **/
uint8_t PROTOCOL_uartBuffer[PROTOCOL_SIZERXBUF] = {0};
ringbuffer_hdl_t PROTOCOL_rx_buffer;

static boolean_t REMOTE__isSynced = FALSE;

/**
 * As the sender and receiver possibly do not start at the same time and we might suffer from boot-bytes, 
 * all bytes are ignored until we find the first true byte in the sequence
 * later on, this concept may also be used for resynchronisation
 * \param uint8_t data  : IN Byte currently received
 * \ return: TRUE if system is in sync, false otherwise
 */
boolean_t PROTOCOL_SyncProtocol(uint8_t data)
{
    //Identify valid start of protocol identifier
    if (PROT_MID__CONNECT == data ||
        PROT_MID__JOYSTICK   == data)
    {
        REMOTE__isSynced = TRUE;
    }
    
    return REMOTE__isSynced;
}

/**
 * In case a transmission error occurs, the system shall wait for the next valid protocol
 * For this, we set the corresponding flag to FALSE again
 */
void PROTOCOL_UnsyncProtocol()
{
    REMOTE__isSynced = FALSE;
}

/**
 * Calculate the protocol CRC based on the transmitted data mid, sender, receiverm fid and payload
 * This value will be compared with the transmittet CRC
 **/
static uint8_t PROTOCOL__computeCRC(uint8_t mid, uint8_t sender, uint8_t receiver, uint8_t fid, uint8_t const len, uint8_t const * const data) {

	uint8_t tempcrc = 0xff;
	tempcrc =  (uint8_t) (tempcrc ^ mid ^ sender ^ receiver ^ fid ^ len);

	for (int itr = 0; itr < len; itr++)
	{
		tempcrc = (uint8_t) (tempcrc ^ data[itr]);
	}

	return tempcrc;
}


    //Hacky, how about a reconnect? Ignored for the time being
    static int8_t XBEE_connectedPartner = 0;

/* USER CODE END SC_PROTOCOL_USERDEFINITIONS */


/*****************************************************************************************
 *************** Port Wrapper Implementation for SC_PROTOCOL signal  ****************
 *****************************************************************************************/
 
 

/**
 * Default IN driver API
 */
inline RC_t SC_PROTOCOL_driverIn(SC_PROTOCOL_data_t *const data)
{
	/* USER CODE START driverInSC_PROTOCOL */
    
    //Received a complete protocol, let's clock out the data
	//We will first write the data to locals and check if everything is ok.
	//If this is the case, the signal will be written

	uint8_t mid = 0;
	uint8_t sender = 0;
	uint8_t receiver = 0;
	uint8_t fid = 0;
	uint8_t length = 0;
	uint8_t featureData[PROTOCOL_PAYLOAD_SIZE];
	uint8_t crc = 0;
	uint8_t eop1 = 0;
	uint8_t eop2 = 0;

	RC_t result = RC_ERROR; //local return code
    RC_t ret= RC_SUCCESS;   //final return code (function)

	//MID
	result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &mid);
	if (RC_SUCCESS != result) {
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}

	//Sender
	result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &sender);
	if (RC_SUCCESS != result) {
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}

	//Receiver
	result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &receiver);
	if (RC_SUCCESS != result) {
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}

	//FID
	result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &fid);
	if (RC_SUCCESS != result) {
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}

	//Payload Length (must be 2 or more)
	result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &length);
	if (RC_SUCCESS != result || length > PROTOCOL_PAYLOAD_SIZE) {
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}

	//Payload
	for (uint8_t i = 0; i < length; i++)
	{
		result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &featureData[i]);
		if (RC_SUCCESS != result) {
			Ringbuffer_Clear(&PROTOCOL_rx_buffer);
			ret =  RC_ERROR_BUFFER_EMTPY;
		}
	}

	//CRC
	result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &crc);
	if (RC_SUCCESS != result) {
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}

	result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &eop1);
	if (RC_SUCCESS != result) {
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}

	result = Ringbuffer_Get(&PROTOCOL_rx_buffer, &eop2);
	if (RC_SUCCESS != result) {
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}


	//========== Validation


	//In case of the present message, we have to set the connected partner id
	if (PROT_FID_Present == fid)
	{
		XBEE_connectedPartner = sender;
	}

	//Check for correct sender and receiver
	if (! (sender == XBEE_connectedPartner || receiver == CONFIG_REMOTE_BROADCAST)){
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BUFFER_EMTPY;
	}

	if (! (receiver == CONFIG_REMOTE_CAR_ID || receiver == CONFIG_REMOTE_BROADCAST)){
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_BAD_DATA;
	}

	//Check for CRC
	if (! (crc == PROTOCOL__computeCRC(mid, sender, receiver, fid, length, featureData))){
		Ringbuffer_Clear(&PROTOCOL_rx_buffer);
		ret =  RC_ERROR_CHECKSUM;
	}

	//EOP have been checked before

	//All ok, let's copy the data into the signal
	if (RC_SUCCESS == ret )
	{
		/* ---- Copy data from uart buffer to data fields ---- */
		data->m_mid 	= mid;
		data->m_length	= length;
		data->m_fid		= fid;

		for ( int i = 0; i < length ; i++){
			data->m_payload[i] = featureData[i];
		}
	}

	return ret;
	/* USER CODE END driverInSC_PROTOCOL */
}
/**
 * Default OUT driver API
 */
inline RC_t SC_PROTOCOL_driverOut(const SC_PROTOCOL_data_t  *const data)
{
	/* USER CODE START driverOutSC_PROTOCOL */

	/*
	 * Structure of the protocol: ID SENDER_ID RECEIVER_ID  FEATURE_ID LENGTH FEATURE_DATA CRC EOP1 EOP2
	 * Length of payload (changed)
	 * Note: In the protocol message representation , the length attribute reflects the length of the payload + FID + CRC , i.e. 2 elements more.
	 * Check: https://web.eit.h-da.de/studentcar_trac/wiki/car3_uart_remote
	 */

	//usbLog.printf_c(Log::DBG, "REMOTE", "send (MID, FID)",2 , (char)payload.m_mid, (char)payload.m_fid );

	//Construct the protocol only if payload fits
	if (data->m_length < PROTOCOL_PAYLOAD_SIZE)
	{

		XBee_PutChar(data->m_mid);
		XBee_PutChar(CONFIG_REMOTE_CAR_ID);
		XBee_PutChar(XBEE_connectedPartner); //Todo a bit hacky, using a global to identify the other side. Set upon 'P' protocol reception in the scaler.
		XBee_PutChar(data->m_fid);

		XBee_PutChar(data->m_length);

		for (uint16_t i = 0; i < data->m_length; i++)
		{
			XBee_PutChar(data->m_payload[i]);
		}

		uint8_t crc = PROTOCOL__computeCRC(data->m_mid, CONFIG_REMOTE_CAR_ID, XBEE_connectedPartner,  data->m_fid, data->m_length, data->m_payload);
		XBee_PutChar(crc);

		XBee_PutChar(PROTOCOL_EOP1_VALUE);
		XBee_PutChar(PROTOCOL_EOP2_VALUE);

	}
	else
	{
		//Todo: some error handling
	}

	return RC_SUCCESS;
	/* USER CODE END driverOutSC_PROTOCOL */
}



