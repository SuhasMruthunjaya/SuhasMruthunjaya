/*
 * Filename: swc_remote.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: Remote control, reading / sending XBee protocols
 * name: swc_remote
 * shortname: remote
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "swc_remote.h"



/* USER CODE START SWC_REMOTE_INCLUDE */
#include "logging.h"
/* USER CODE END SWC_REMOTE_INCLUDE */


#include "sp_common.h"

/* USER CODE START SWC_REMOTE_USERDEFINITIONS */

/* USER CODE END SWC_REMOTE_USERDEFINITIONS */



/*
 * component: swc_remote
 * cycletime: 0
 * description: Receives outgoing event and creates and XBee protocol
 * events: ev_eventout_onData
 * name: REMOTE_transmit_run
 * shortname: transmit
 * signalIN: so_eventOut
 * signalOUT: so_protocolTx
 * task: tsk_io
 */
void REMOTE_transmit_run(RTE_event ev){
	
	/* USER CODE START REMOTE_transmit_run */
    

	SC_PROTOCOL_data_t outProt = SC_PROTOCOL_INIT_DATA;
    SC_EVENT_OUT_data_t evOut = SC_EVENT_OUT_INIT_DATA;

	//Read local payload of remote protocol
	//RC_SUCCESS will only be returned if status is valid 
	 evOut= RTE_SC_EVENT_OUT_get(&SO_EVENTOUT_signal);
    
    RC_t res = RC_SUCCESS;

    //Todo some error handling, either by checking validity or age or using a specific error runnable
    
	switch (evOut.m_ev)
	{
	case EV_OUT_ACK_PRESENT:
		outProt.m_mid = PROT_MID__CONNECT;
		outProt.m_length = 0;
		outProt.m_fid = PROT_FID_Present;
		break;

	case EV_OUT_ACK_CONNECT:
		outProt.m_mid = PROT_MID__CONNECT;
		outProt.m_length = 0;
		outProt.m_fid = PROT_FID_Connect;

		//Copy feature payload
		if (evOut.m_lengthPayload < PROTOCOL_PAYLOAD_SIZE)
		{
			outProt.m_length = evOut.m_lengthPayload;

			for (uint16_t i = 0; i < evOut.m_lengthPayload; i++)
			{
				outProt.m_payload[i] = evOut.m_payload[i];
			}
            
		}
		else
		{
			//Error, payload does not fit
			outProt.m_length = 0;
            res = RC_ERROR_BAD_DATA;
		}
		break;

	case EV_OUT_ACK_DISCONNECT:
		outProt.m_mid = PROT_MID__CONNECT;
		outProt.m_length = 0;
		outProt.m_fid = PROT_FID_Disconnect;
		break;

	case EV_OUT_FEATURELIST:
		outProt.m_mid = PROT_MID__CONNECT;
		outProt.m_length = 0;
		outProt.m_fid = PROT_FID_Feature;

		//Copy feature payload
		if (evOut.m_lengthPayload < PROTOCOL_PAYLOAD_SIZE)
		{
			outProt.m_length = evOut.m_lengthPayload;

			for (uint16_t i = 0; i < evOut.m_lengthPayload; i++)
			{
				outProt.m_payload[i] = evOut.m_payload[i];
			}
		}
		else
		{
			//Error, payload does not fit
			outProt.m_length = 0;
            res = RC_ERROR_BAD_DATA;
		}
		break;

	case EV_OUT_INFO:

		break;

	case EV_OUT_NONE : //Fallthrough
	default: res = RC_ERROR_INVALID_STATE; break;
	}

	if (RC_SUCCESS == res)
	{
		//Send out resulting remote protocol
		RTE_SC_PROTOCOL_set(&SO_PROTOCOLTX_signal, outProt);
		res = RTE_SC_PROTOCOL_pushPort(&SO_PROTOCOLTX_signal);
        
        //LOG_I("tx","mid: %d fid: %d len: %d",outProt.m_mid, outProt.m_fid, outProt.m_length);
        
        //Todo add error handler
	}
	else
	{
		//Todo: Oops, something went worng
	}

    /* USER CODE END REMOTE_transmit_run */
}

/*
 * component: swc_remote
 * cycletime: 0
 * description: Receive an incoming protocol and translates the content into joystick or event signal
 * events: ev_xbee_rx
 * name: REMOTE_receive_run
 * shortname: receive
 * signalIN: so_protocolRx
 * signalOUT: so_joystick|so_eventIn
 * task: tsk_io
 */
void REMOTE_receive_run(RTE_event ev){
	
	/* USER CODE START REMOTE_receive_run */
    
    //Create some locals for the signal data payload
    SC_PROTOCOL_data_t protocol = SC_PROTOCOL_INIT_DATA;
    SC_JOYSTICK_data_t joystick = SC_JOYSTICK_INIT_DATA;
    SC_EVENT_IN_data_t event = SC_EVENT_IN_INIT_DATA;
    
    //Read in the protocol from the ringbuffer
    RC_t result = RTE_SC_PROTOCOL_pullPort(&SO_PROTOCOLRX_signal);
    
    
    //In case of an error, the error runnable will be called.
    //But we should not process the data in this case, so let's check it
    //We could also check the signal validity status, but this will provide the same information
    
    if (RC_SUCCESS == result)
    {
        //We have a valid protocol, so let's check the content
        protocol = RTE_SC_PROTOCOL_get(&SO_PROTOCOLRX_signal);
        //LOG_I("rx","mid: %c fid : %c", protocol.m_mid, protocol.m_fid);     
        
        
        //============================= Translate FID into abstract event for connection state machine ================================================

		if (PROT_MID__CONNECT == protocol.m_mid) {

			switch (protocol.m_fid) {
			case PROT_FID_Present:
				event.m_ev = EV_IN_Present;
				break;
			case PROT_FID_Connect:
				event.m_ev = EV_IN_Connect;
				break;
			case PROT_FID_Disconnect:
				event.m_ev = EV_IN_Disconnect;
				break;
			case PROT_FID_Stop:
				event.m_ev = EV_IN_Stop;
				break;
			case PROT_FID_Reset:
				event.m_ev = EV_IN_Reset;
				break;
			case PROT_FID_Feature:
				event.m_ev = EV_IN_RequestFeature;
				break;
			case PROT_FID_Activate: //Here, payload is required
				event.m_ev = EV_IN_ActivateFeature;
				event.m_lengthPayload = protocol.m_length;
				for (uint8_t i = 0; i < protocol.m_length; i++) {
					event.m_payload[i] = protocol.m_payload[i];
				}
				break;
			case PROT_FID_Brake: /* ignored */

			default:
				event.m_ev = EV_IN_NoEvent;
				break;
			}

			//Update signal
			if (event.m_ev != EV_IN_NoEvent) {
                //LOG_I("rx","Fire event");
				result = RTE_SC_EVENT_IN_set(&SO_EVENTIN_signal, event);
			}
		}

		//============================= Translate Joystick Data  ================================================

		/**
		 *
		 *		Protocol Item 	Content 		Range
		 *		MID 			'J'
		 *		FID 			'J'
		 * 		Payload[0] 		Joystick x 		-100..100
		 * 		Payload[1] 		Joystick y 		-100..100
		 *		Payload[3] opt 	Joystick phi 	-100..100
		 *		Payload[4] opt 	Emergency Brake 0..1
		 *		Payload[5] opt 	Normal Brake 	0..1
		 *
		 * Please check https://web.eit.h-da.de/studentcar_trac/wiki/car3_uart_remote for a description of the structure
		 *
		 */

		else if (PROT_MID__JOYSTICK == protocol.m_mid) {

			switch (protocol.m_fid) {
			case PROT_FID_Joystick:
				joystick.m_x = (sint8_t) protocol.m_payload[0];
				joystick.m_y = (sint8_t) protocol.m_payload[1];

				//The next protocol parts are optional, therefore the length of the transferred needs to be checked
				if (protocol.m_length > 2)	joystick.m_z = (sint8_t) protocol.m_payload[2];
				if (protocol.m_length > 3)	joystick.m_emergencyStop = protocol.m_payload[3];
				if (protocol.m_length > 4)	joystick.m_normalStop = protocol.m_payload[4];

			default: /* Todo error handling */ break;
			}

			result = RTE_SC_JOYSTICK_set(&SO_JOYSTICK_signal, joystick);

		}
	} else {
		//Todo some decent error handling
		//At the moment - simply set the joystick to NULL position and do not transfer any events

        //LOG_I("rx err","%d",result);
        
		joystick = SC_JOYSTICK_INIT_DATA;
		result = RTE_SC_EVENT_IN_set(&SO_EVENTIN_signal, event);

		return;
	}


    /* USER CODE END REMOTE_receive_run */
}

/*
 * component: swc_remote
 * cycletime: 100
 * description: Error handler for Remote. Triggers on invalid data and wrong age. Will call central error handler as escalation.
 * events: ev_protocolrx_onError
 * name: REMOTE_error_run
 * shortname: error
 * signalIN: so_protocolRx|so_protocolTx
 * signalOUT: 
 * task: tsk_io
 */
void REMOTE_error_run(RTE_event ev){
	
	/* USER CODE START REMOTE_error_run */

    /* USER CODE END REMOTE_error_run */
}

/* USER CODE START SWC_REMOTE_FUNCTIONS */

/* USER CODE END SWC_REMOTE_FUNCTIONS */

