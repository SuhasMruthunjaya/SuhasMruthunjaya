/*
 * Filename: swc_control.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: SWC containing ADAS and manual driving functions
 * name: swc_control
 * shortname: control
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "swc_control.h"



/* USER CODE START SWC_CONTROL_INCLUDE */

#include "logging.h"
#include "statemachine.h"
#include "CTRL_manual.h"
#include "CTRL_autonomous.h"
#include "det.h"


/* USER CODE END SWC_CONTROL_INCLUDE */


#include "sp_common.h"

/* USER CODE START SWC_CONTROL_USERDEFINITIONS */

/** ---------------------------------- Actions -------------------------------------- **/

/**
 * Will send an acknowledge protocol
 */
static void CONTROL__action_confirmPresent();

/**
 * Will send an acknowledge protocol
 */
static void CONTROL__action_confirmConnect();

/**
 * Will send an acknowledge protocol
 */
static void CONTROL__action_confirmDisconnect();

/**
 * Will send the list of available features
 */
static void CONTROL__action_provideFeatureList();

/**
 * Will start the feature identified by the payload inside the event signal
 */
static void CONTROL__action_activateFeature();

/**
 * Will set the max allowed speed to 0
 */
static void CONTROL__action_initCar();


/** ---------------------------------- Transitions ---------------------------------------- **/

/**  ===== IS_IDLE ====   */
static const STATE_stateInnerTransitionTable_t CONTROL_ISIDLE_Transitions = {
/*    Event                 ToState                 		 Guard                       Action                       */
    { EVENT(EV_IN_Present), STATE(CONNECTIONSTATE_IS_IDLE),      0,                          CONTROL__action_confirmPresent},
	{ EVENT(EV_IN_Connect),	STATE(CONNECTIONSTATE_IS_CONNECTED), 0, /*Todo add guard */ 	 CONTROL__action_confirmConnect},
};


/**  ===== IS_CONNECTED ====   */
static const STATE_stateInnerTransitionTable_t CONTROL_ISCONNECTED_Transitions = {
/*    Event                         ToState                 		      Guard                       Action                       */
    { EVENT(EV_IN_Reset),           STATE(CONNECTIONSTATE_IS_IDLE),     0,                          0},
    { EVENT(EV_IN_Disconnect),      STATE(CONNECTIONSTATE_IS_IDLE),     0,                          CONTROL__action_confirmDisconnect},
    { EVENT(EV_IN_RequestFeature),  STATE(CONNECTIONSTATE_IS_CONNECTED),0,                          CONTROL__action_provideFeatureList},
    { EVENT(EV_IN_ActivateFeature), STATE(CONNECTIONSTATE_IS_DRIVING),  0,  /* Todo add guard */    CONTROL__action_activateFeature},
};

/**  ===== IS_DRIVING ====   */
static const STATE_stateInnerTransitionTable_t CONTROL_ISDRIVING_Transitions = {
/*    Event                   ToState                 		 Guard                       Action                       */
    { EVENT(EV_IN_Reset),     STATE(CONNECTIONSTATE_IS_IDLE),  0,                          0},
    { EVENT(EV_IN_Disconnect),STATE(CONNECTIONSTATE_IS_IDLE),  0,                          CONTROL__action_confirmDisconnect},
};


/**
 * Note: The casting is required because
 * 	- We cannot store element of unknown size inside a class unless it is placed at the end of the memory section
 * 	- At the same time, we need the array of undefined size to allocate memory in the assignments above
 * 	- As a consequence, some nasty casts are required to translate the address of the array into a normal pointer
 */
static const STATE_stateOuterTransitionTable_t CONTROL_Connection_Transitions = {
/*    fromState                             Pointer to table                            Size of table [Elements]    */
    { STATE(CONNECTIONSTATE_IS_IDLE),       &CONTROL_ISIDLE_Transitions,                sizeof(CONTROL_ISIDLE_Transitions)/sizeof(STATE_stateInnerTransition_t)    },
    { STATE(CONNECTIONSTATE_IS_CONNECTED),  &CONTROL_ISCONNECTED_Transitions,           sizeof(CONTROL_ISCONNECTED_Transitions)/sizeof(STATE_stateInnerTransition_t)     },
    { STATE(CONNECTIONSTATE_IS_DRIVING),    &CONTROL_ISDRIVING_Transitions,             sizeof(CONTROL_ISDRIVING_Transitions)/sizeof(STATE_stateInnerTransition_t) },
};
//static const uint16_t CONTROL_Connection_Transitions_size = sizeof(CONTROL_Connection_Transitions)/sizeof(STATE_stateOuterTransition_t);

/** ---------------------------------- Action Table ------------------------------------------- **/

static const STATE_stateAction_t CONTROL_Connection_StateActions[] = {
/*  fromState                           Entry                           Exit    */
  { STATE(CONNECTIONSTATE_IS_IDLE),     CONTROL__action_initCar,        0   }
};
//static const uint16_t CONTROL_Connection_StateActions_size = sizeof(CONTROL_Connection_StateActions)/sizeof(STATE_stateAction_t);

/** ---------------------------------- State Machine Object --------------------------------- **/

//Todo: FOr some strange reasons, I cannot assign the variables CONTROL_Connection_Transitions_size, CONTROL_Connection_StateActions_size , only the sizeof operations directly...

/**
 * The connection state machine object 
 **/
STATE_t CONTROL_ConnectionFSM = {
    &CONTROL_Connection_Transitions,
    sizeof(CONTROL_Connection_Transitions)/sizeof(STATE_stateOuterTransition_t),
    
    &CONTROL_Connection_StateActions,
    sizeof(CONTROL_Connection_StateActions)/sizeof(STATE_stateAction_t),
    
    STATE(CONNECTIONSTATE_IS_IDLE)
};
    
    

/** ---------------------------------- Feature table --------------------------------- **/

/**
 * function pointer used for actions
 */
typedef void (*CONTROL_RunPtr_t)();


#define CONTROL_FEATURESTRINGLENGTH 15        //First byte is reserved for index, \0 for termination

typedef struct
{
    CONTROL_RunPtr_t m_run;                                         /**< \brief Pointer to the control loop runnable */
    char             m_description[CONTROL_FEATURESTRINGLENGTH];    /**< \brief string description */
} CONTROL_Feature_t;

static CONTROL_Feature_t CONTROL_FeatureTable[] = {
    /** Runnable                            Description */
    /**                                      123456789012345| */
    { CTRL_manual_run,                      "Joystick"},
    { CTRL_obstacleAvoidance_run,           "Avoid Obstacle"},
};
static const uint16_t CONTROL_FeatureTable_size = sizeof(CONTROL_FeatureTable)/sizeof(CONTROL_Feature_t);

/* USER CODE END SWC_CONTROL_USERDEFINITIONS */



/*
 * component: swc_control
 * cycletime: 0
 * description: Central runnable calling the set driving function based on the carstate signal
 * events: ev_joystick_onData
 * name: CONTROL_control_run
 * shortname: control
 * signalIN: so_joystick
 * signalOUT: so_targetspeed
 * task: tsk_control
 */
void CONTROL_control_run(RTE_event ev){
	
	/* USER CODE START CONTROL_control_run */
    
    //Read the state from the signal
    SC_CARSTATE_data_t carstate = SC_CARSTATE_INIT_DATA;
    carstate = RTE_SC_CARSTATE_get(&SO_CARSTATE_signal);
    
    //Read the connection state from the state machine
    CONNECTION_state_t connectionState = (CONNECTION_state_t)STATE_getCurrentState(&CONTROL_ConnectionFSM);
    
    //Check for correct index and driving state
    if (CONNECTIONSTATE_IS_DRIVING == connectionState && carstate.m_algoIndex >= 0 && carstate.m_algoIndex < CONTROL_FeatureTable_size)
    {
        CONTROL_FeatureTable[carstate.m_algoIndex].m_run();
    }
    else
    {
        
    }    

    /* USER CODE END CONTROL_control_run */
}

/*
 * component: swc_control
 * cycletime: 0
 * description: Runnable receiving and processing central events, e.g. related to the connection state of the remote.
 * events: ev_eventin_onData
 * name: CONTROL_processCarstate_run
 * shortname: processCarstate
 * signalIN: so_carState|so_eventIn|so_eventOut
 * signalOUT: so_carState|so_eventOut
 * task: tsk_control
 */
void CONTROL_processCarstate_run(RTE_event ev){
	
	/* USER CODE START CONTROL_processCarstate_run */
    
    //Local data
    SC_EVENT_IN_data_t ev_in = SC_EVENT_IN_INIT_DATA;
    
    //Read the event
    ev_in = RTE_SC_EVENT_IN_get(&SO_EVENTIN_signal);
	EVENT_in_t ev_fsm = ev_in.m_ev;
    
    //LOG_I("FSM","ev_rx %d state %d",ev_in.m_ev, carstate.m_state);
    
    //Some DET Logging
    DET_report(&DET, DET_FSM_EVENT, (uint32_t)ev_fsm);
    
    
	//Execute Connection State Machine
	STATE_processEvent(&CONTROL_ConnectionFSM, EVENT(ev_fsm));
    
    DET_report(&DET, DET_FSM_STATE, (uint32_t)STATE_getCurrentState(&CONTROL_ConnectionFSM));

    /* USER CODE END CONTROL_processCarstate_run */
}

/* USER CODE START SWC_CONTROL_FUNCTIONS */


//----------- User Functions

//Start of user code usr_functions

/**
 * Will send an acknowledge protocol
 */
static void CONTROL__action_confirmPresent()
{

    SC_EVENT_OUT_data_t ev = SC_EVENT_OUT_INIT_DATA;

	//Create payload
    ev.m_ev = EV_OUT_ACK_PRESENT;

	//And out it goes to the remote transmission
	RTE_SC_EVENT_OUT_set(&SO_EVENTOUT_signal, ev);

}

/**
 * Will send an acknowledge protocol
 */
static void CONTROL__action_confirmConnect()
{
    SC_EVENT_OUT_data_t ev = SC_EVENT_OUT_INIT_DATA;

	//Create payload
    ev.m_ev = EV_OUT_ACK_CONNECT;

	//And out it goes to the remote transmission
	RTE_SC_EVENT_OUT_set(&SO_EVENTOUT_signal, ev);
}

/**
 * Will send an acknowledge protocol
 */
static void CONTROL__action_confirmDisconnect()
{
    //Todo: This protocol is ignored on remote side, may be added later for checking
    SC_EVENT_OUT_data_t ev = SC_EVENT_OUT_INIT_DATA;

	//Create payload
    ev.m_ev = EV_OUT_ACK_DISCONNECT;

	//And out it goes to the remote transmission
	RTE_SC_EVENT_OUT_set(&SO_EVENTOUT_signal, ev);
}

/**
 * Will send the list of available features
 */
static void CONTROL__action_provideFeatureList()
{
    SC_EVENT_OUT_data_t ev = SC_EVENT_OUT_INIT_DATA;
    ev.m_ev = EV_OUT_FEATURELIST;

    uint8_t pos = 0;
    //LOG_I("FL","start");

    //Stringnify the existing features
    for (uint8_t i = 0; i < CONTROL_FeatureTable_size; i++)
    {
        //LOG_I("CONTROL__action_provideFeatureList","Processing Feature %d of %d", i, CONTROL_FeatureTable_size);

        uint8_t len = strlen(CONTROL_FeatureTable[i].m_description);

        //Should not happen, but who knows
        if (len >= CONTROL_FEATURESTRINGLENGTH) len = CONTROL_FEATURESTRINGLENGTH;

        //Copy string content
        for (uint8_t l = 0; l < len; l++)
        {
            ev.m_payload[pos++] = CONTROL_FeatureTable[i].m_description[l];
            if (pos >= EVENT_PAYLOADSIZE)
            {
                LOG_E("CONTROL__action_provideFeatureList","payload too large");
                return;
            }

        }
        ev.m_payload[pos++] = '\0'; //String termination
        if (pos >= EVENT_PAYLOADSIZE)
        {
            LOG_E("CONTROL__action_provideFeatureList","payload too large");
            return;
        }
    }

    //Set resulting payload size
    ev.m_lengthPayload = pos;

	//And out it goes to the remote transmission
	RTE_SC_EVENT_OUT_set(&SO_EVENTOUT_signal, ev);
}

/**
 * Will start the feature identified by the payload inside the event signal
 */
static void CONTROL__action_activateFeature()
{
    
    //Note: We use ptr API as we don't want to fire an event in case one is defined
    SC_CARSTATE_data_t* carstate = 0;
    SC_EVENT_IN_data_t event = SC_EVENT_IN_INIT_DATA;

    carstate = RTE_SC_CARSTATE_getPtr(&SO_CARSTATE_signal);
    event = RTE_SC_EVENT_IN_get(&SO_EVENTIN_signal);
    
    //Read algo index from event
	carstate->m_algoIndex = (sint8_t)event.m_payload[0];
    
    //Write resulting carstate
    //RTE_SC_CARSTATE_set(&SO_CARSTATE_signal,carstate);
    // As we do not want to fire an event here, we only update the index by pointer


}

/**
 * Will set the max allowed speed to 0
 */
static void CONTROL__action_initCar()
{

    //Note: We use ptr API as we don't want to fire an event in case one is defined
    
    SC_CARSTATE_data_t* carstate = 0;
    
    carstate = RTE_SC_CARSTATE_getPtr(&SO_CARSTATE_signal);
    
    //Read algo index from event
	carstate->m_algoIndex = -1;
    
    //Write resulting carstate
    //RTE_SC_CARSTATE_set(&SO_CARSTATE_signal,carstate);

}



/* USER CODE END SWC_CONTROL_FUNCTIONS */

