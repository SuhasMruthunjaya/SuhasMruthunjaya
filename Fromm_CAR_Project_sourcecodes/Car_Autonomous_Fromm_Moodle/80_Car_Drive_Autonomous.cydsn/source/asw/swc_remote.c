/**************************************************
 ** Software Component SWC_Remote
 ** autogenerated by H-DA RTE Generator
 **************************************************/

#include "rte.h"
#include "rte_signalpool.h"

#include "logging.h"

#include "signal_protocol_type.h"
#include "ringbuffer.h"

#include "swc_remote.h"

#include "signal_protocol_type.h"



    

/** --------------------------------- Runnables ---------------------------------- **/

void REMOTE_init_run()
{
    RC_t result = RC_SUCCESS;
    
    //Start UART communication
    UART_Zigbee_Start();

    
    //Create RINGBUFFER object
    result = Ringbuffer_Init(&REMOTE_rx_buffer, RINGBUFFER_NO_ERIKA_RES, &REMOTE_uartBuffer, PROT_SIZERXBUF);
    
    //Todo error handling
}


void REMOTE_sendProtocol_run()
{
    //Read in internal message
    SIGNAL_EVENT_data_t event = SIGNAL_EVENT_INIT_DATA;
    event = RTE_SIGNAL_EVENT_get(&SO_EVENT_TX_signal);
    
    //Translate message into protocol
    SIGNAL_PROTOCOL_data_t prot = SIGNAL_PROTOCOL_INIT_DATA;
    
    if (EV_Feature_List == event.m_ev)
    {
        //Activate feature
        prot.m_id = PROT_ID_Connection;
        prot.m_sender = PROT_sender_car;
        prot.m_fid = PROT_FID_Feature;
        prot.m_length = event.m_lengthPayload;
        
        //Copy payload
        for (uint8_t i = 0; i < prot.m_length; i++) 
        {
            prot.m_payload[i] = event.m_payload[i];
        }
        
        LOG_I("REMOTE_sendProtocol_run","Sending Feature : %d", prot.m_payload[0]);
    }
    else
    {
        //All other simple events without payload
        prot.m_id = PROT_ID_Connection;
        prot.m_sender = PROT_sender_car;
        switch (event.m_ev)
        {
            case EV_Connect_ACK : prot.m_fid = PROT_FID_Connect; break;
            case EV_Disconnect_ACK : prot.m_fid = PROT_FID_Disconnect; break;
            default: LOG_E("REMOTE_sendProtocol_run","wrong event: %d",event.m_ev); break;
        }
    }
    
    RTE_SIGNAL_PROTOCOL_set(&SO_PROTOCOLTX_signal, prot);
    RTE_SIGNAL_PROTOCOL_pushPort(&SO_PROTOCOLTX_signal);

}


void REMOTE_readProtocol_run()
{
    //Read in the protocol data
    SIGNAL_PROTOCOL_data_t prot = SIGNAL_PROTOCOL_INIT_DATA;

    RC_t result = RTE_SIGNAL_PROTOCOL_pullPort(&SO_PROTOCOLRX_signal);
    
    if (RC_SUCCESS != result)
    {
        LOG_E("REMOTE_read","error %d", result);
    }
    
    prot = RTE_SIGNAL_PROTOCOL_get(&SO_PROTOCOLRX_signal);
       
    //LOG_I("Prot:","%c %c %c %d",prot.m_id, prot.m_sender, prot.m_fid, prot.m_length);
    
    //Now let's process the content
    if (prot.m_id == PROT_ID_Joystick)
    {
        SIGNAL_JOYSTICK_data_t joystick = SIGNAL_JOYSTICK_INIT_DATA;
        joystick.m_x = (sint8_t)prot.m_payload[0];
        joystick.m_y = (sint8_t)prot.m_payload[1];
        
         //LOG_I("Joystick:","%d %d ",joystick.m_x, joystick.m_y);
        
        
        RTE_SIGNAL_JOYSTICK_set(&SO_JOYSTICK_signal, joystick);
        
        
        //Event needs to be fired in addition for event trigger
        SIGNAL_EVENT_data_t event = SIGNAL_EVENT_INIT_DATA;
        event.m_ev = EV_Joystick;
        RTE_SIGNAL_EVENT_set(&SO_EVENT_RX_signal, event);
    }
    else if (prot.m_id == PROT_ID_Connection)
    {
        SIGNAL_EVENT_data_t event = SIGNAL_EVENT_INIT_DATA;
        
        switch (prot.m_fid)
        {
            case PROT_FID_Activate   : // 'A'  request feature activation
                event.m_ev = EV_ActivateFeature;
                event.m_lengthPayload = prot.m_length;
                for (uint8_t i = 0; i < prot.m_length; i++)
                {
                    event.m_payload[i] = prot.m_payload[i];
                }
                break;
            
            case PROT_FID_Connect    : // 'C'  request connection
                event.m_ev = EV_Connect;
                break;
            
            case PROT_FID_Feature    : // 'F' request list of features 
                event.m_ev = EV_RequestFeature;
                break;
            
            case PROT_FID_Disconnect : // 'D' request disconnect
                event.m_ev = EV_Disconnect;
                break;

            case PROT_FID_Reset       : // 'R' request state machine reset
                event.m_ev = EV_Reset;
                break;

            
            case PROT_FID_Stop       : // 'S' request emergency stop
                event.m_ev = EV_Stop;
                break;
            
            default:
                event.m_ev = EV_NoEvent;
                LOG_E("REMOTE_read","Wrong FID rx : %d", prot.m_fid);
        }
        
        //Send signal to FSM
        RTE_SIGNAL_EVENT_set(&SO_EVENT_RX_signal, event);
    }

}


void REMOTE_readProtocolError_run()
{

    //This function will be fired after EOP has been received
    //To resync, the ringbuffer is cleared
    Ringbuffer_Clear(&REMOTE_rx_buffer);
    LOG_E("REMOTE_readProtocolError_run","clear buffer");
}

//Value of 1000 will make buffer overrun visible
#define TESTRUNS 200

void REMOTE_testProtocol_run()
{

    
    for (int i = 0; i < TESTRUNS; i++)
    {
        UART_Zigbee_PutString("Hello World 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n");
    }
    
    /*
    SIGNAL_PROTOCOL_data_t prot = SIGNAL_PROTOCOL_INIT_DATA;
    prot.m_id = PROT_ID_Connection;
    prot.m_sender = PROT_sender_car;
    prot.m_fid = PROT_FID_Connect;
    prot.m_length = 0;
    
    RTE_SIGNAL_PROTOCOL_set(&SO_PROTOCOLTX_signal, prot);
    RTE_SIGNAL_PROTOCOL_pushPort(&SO_PROTOCOLTX_signal);
    */
    
}