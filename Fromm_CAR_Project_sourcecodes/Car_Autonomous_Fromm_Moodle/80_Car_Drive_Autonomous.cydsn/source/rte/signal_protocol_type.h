/*
 * Signal_Protocol_type.h
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 */



#ifndef SIGNAL_PROTOCOL_TYPE_H_
#define SIGNAL_PROTOCOL_TYPE_H_

#include "global.h"
#include "ringbuffer.h"
    
/*****************************************************************************************
 *************** Type Definition for SIGNAL_PROTOCOL signal                     **************************
 *****************************************************************************************/

    
 
    
typedef enum
    {
        PROT_ID_Connection = 'C',        /**<\brief connection state related protocol */
        PROT_ID_Joystick   = 'J',        /**<\brief joystick data related protocol */
    } PROT_id_t;

typedef enum
    {
        PROT_FID_Activate   = 'A',       /**<\brief Activate Feature (remote) */
        PROT_FID_BRAKE      = 'B',       /**<\brief brake pressed (remote) */
        PROT_FID_Connect    = 'C',       /**<\brief request connection (remote), confirm connection (car) */
        PROT_FID_Feature    = 'F',       /**<\brief request list of features (remote), provide features (car) */
        PROT_FID_Disconnect = 'D',       /**<\brief request disconnect (remote), confirm disconnect (car) */
        PROT_FID_Joystick   = 'J',       /**<\brief joystick data package (remote) */
        PROT_FID_Reset      = 'R',       /**<\brief request state machine reset without answer (remote) */
        PROT_FID_Stop       = 'S',       /**<\brief request emergency stop (remote) */
        
    } PROT_fid_t;

typedef enum
    {
        PROT_sender_car   =  'C',        /**<\brief car id */
        PROT_sender_remote = 'R',        /**<\brief remote id */
        
    } PROT_sender_t;

    
#define PROT_SIZEPAYLOAD 40              /**< \brief Payload size (max) */
#define PROT_SIZERXBUF   100             /**< \brief Size of the UART reception buffer */
#define PROT_EOP1        0x0D            /**< \breif EOP character 1 */
#define PROT_EOP2        0x0E            /**< \breif EOP character 2 */
    
typedef struct
{
    PROT_id_t       m_id;                           /**< \brief Protocol ID, first byte in protocol */
    PROT_sender_t   m_sender;                       /**<\ brief identifier of the sender - mainly for debugging */
    PROT_fid_t      m_fid;                          /**<\ brief feature identifier */
    uint8_t         m_length;                       /**<\ length of the valid payload */
    uint8_t         m_payload[PROT_SIZEPAYLOAD];    /**<\ payload */
} SIGNAL_PROTOCOL_data_t;

#define SIGNAL_PROTOCOL_INIT_DATA ((SIGNAL_PROTOCOL_data_t){0})

//We have to declare them external to make them visible for the isr and REMOTE_init
extern ringbuffer_hdl_t REMOTE_rx_buffer;
uint8_t REMOTE_uartBuffer[PROT_SIZERXBUF];   


/**
 * As the sender and receiver possibly do not start at the same time and we might suffer from boot-bytes, 
 * all bytes are ignored until we find the first true byte in the sequence
 * later on, this concept may also be used for resynchronisation
 * \param uint8_t data  : IN Byte currently received
 * \ return: TRUE if system is in sync, false otherwise
 */
boolean_t SIGNAL_PROTOCOL__SyncProtocol(uint8_t data);

/**
 * Default IN driver API - may be deleted if not required
 * \param SIGNAL_PROTOCOL_data_t *const data : [OUT] scaled data read from the driver
 * \return RC_SUCCESS is all was ok, error code otherwise
 */
RC_t SIGNAL_PROTOCOL_driverIn(SIGNAL_PROTOCOL_data_t *const data);


/**
 * Default IN driver API - may be deleted if not required
 * \param const SIGNAL_PROTOCOL_data_t  *const data : [IN] signal data for the driver, will be scaled in this function
 * \return RC_SUCCESS is all was ok, error code otherwise
 */
RC_t SIGNAL_PROTOCOL_driverOut(const SIGNAL_PROTOCOL_data_t  *const data);



#endif /* SIGNAL_PROTOCOL_TYPE_H_ */

