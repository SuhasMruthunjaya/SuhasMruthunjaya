/*
 * Signal_Protocol_type.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 */


#include "project.h"
#include "global.h"

#include "ringbuffer.h"


#include "Signal_Protocol_type.h"

/** ------------------------ Global UART buffers ---------------------------------- **/

uint8_t REMOTE_uartBuffer[PROT_SIZERXBUF] = {0};
ringbuffer_hdl_t REMOTE_rx_buffer;


//static boolean_t REMOTE__isSynced = FALSE;


/*****************************************************************************************
 *************** Port Wrapper Implementation for SIGNAL_PROTOCOL signal     **************
 *****************************************************************************************/

/**
 * Calculate CRC by XOring all data bytes
 */
uint8_t SIGNAL_PROTOCOL__calcCRC(SIGNAL_PROTOCOL_data_t const *const data)
{
    uint8_t crc = 0;
    
    crc = data->m_id ^ data->m_sender ^ data->m_fid ^ data->m_length;
    
    for (uint8 i = 0; i < data->m_length; i++)
    {
        crc = crc ^ data->m_payload[i];
    }
    
    return crc;
}

/** ------------------------ Protocol synchronisation ---------------------------------- **/

static boolean_t REMOTE__isSynced = FALSE;

/**
 * As the sender and receiver possibly do not start at the same time and we might suffer from boot-bytes, 
 * all bytes are ignored until we find the first true byte in the sequence
 * later on, this concept may also be used for resynchronisation
 * \param uint8_t data  : IN Byte currently received
 * \ return: TRUE if system is in sync, false otherwise
 */
boolean_t SIGNAL_PROTOCOL__SyncProtocol(uint8_t data)
{
    //Identify valid start of protocol identifier
    if (PROT_ID_Connection == data ||
        PROT_ID_Joystick   == data)
    {
        REMOTE__isSynced = TRUE;
    }
    
    return REMOTE__isSynced;
}

/**
 * Default IN driver API - may be deleted if not required
 */
inline RC_t SIGNAL_PROTOCOL_driverIn(SIGNAL_PROTOCOL_data_t *const data)
{

    //Scale application data to drive format
    uint8_t protByte = 0;
    RC_t result = RC_SUCCESS;
    
    //Prot_Id
    result = Ringbuffer_Get(&REMOTE_rx_buffer, &protByte);
    if (RC_SUCCESS != result) return result;
    data->m_id = (PROT_id_t)protByte;
    
    //Sender
    result = Ringbuffer_Get(&REMOTE_rx_buffer, &protByte);
    if (RC_SUCCESS != result) return result;
    data->m_sender = (PROT_sender_t)protByte;

    //FID
    result = Ringbuffer_Get(&REMOTE_rx_buffer, &protByte);
    if (RC_SUCCESS != result) return result;
    data->m_fid = (PROT_fid_t)protByte;

    //length
    uint8_t length = 0;
    result = Ringbuffer_Get(&REMOTE_rx_buffer, &length);
    if (RC_SUCCESS != result) return result;
    data->m_length = length;
    
    //Payload
    for (uint8_t i = 0; i < length; i++)
    {
        result = Ringbuffer_Get(&REMOTE_rx_buffer, &protByte);
        if (RC_SUCCESS != result) return result;
        data->m_payload[i] = protByte;
    }
    
    uint8_t checkCrc = SIGNAL_PROTOCOL__calcCRC(data);

    //CRC check
    result = Ringbuffer_Get(&REMOTE_rx_buffer, &protByte);
    if (RC_SUCCESS != result) return result;
    if (checkCrc != protByte) return RC_ERROR_CHECKSUM;
    
    //EOP1 Check
    result = Ringbuffer_Get(&REMOTE_rx_buffer, &protByte);
    if (RC_SUCCESS != result) return result;
    if (PROT_EOP1 != protByte) return RC_ERROR_BAD_DATA;

    //EOP2 Check
    result = Ringbuffer_Get(&REMOTE_rx_buffer, &protByte);
    if (RC_SUCCESS != result) return result;
    if (PROT_EOP2 != protByte) return RC_ERROR_BAD_DATA;

	return RC_SUCCESS;
}

/**
 * Default IN driver API - may be deleted if not required
 */
inline RC_t SIGNAL_PROTOCOL_driverOut(const SIGNAL_PROTOCOL_data_t  *const data)
{


	//Scale application data to drive format
    uint8_t protByte = 0;
    RC_t result = RC_SUCCESS;
    
    //Prot_Id
    UART_Zigbee_WriteTxData((uint8_t)data->m_id);
    
    //Sender
    UART_Zigbee_WriteTxData((uint8_t)data->m_sender);
    
    //Feature id
    UART_Zigbee_WriteTxData((uint8_t)data->m_fid);

    //Length
    UART_Zigbee_WriteTxData(data->m_length);
    
    //Payload
    for (uint8_t i = 0; i < data->m_length; i++)
    {
        UART_Zigbee_WriteTxData(data->m_payload[i]);
    }
    
    //CRC
    uint8_t crc = SIGNAL_PROTOCOL__calcCRC(data);
    UART_Zigbee_WriteTxData(crc);
    
	//EOP
    UART_Zigbee_WriteTxData(PROT_EOP1);
    UART_Zigbee_WriteTxData(PROT_EOP2);
    
	return RC_SUCCESS;
}
