/*
 * Filename: swc_monitor.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: Error monitor checking the system health
 * name: swc_monitor
 * shortname: monitor
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "swc_monitor.h"



/* USER CODE START SWC_MONITOR_INCLUDE */

#include "statemachine.h"
#include "math.h"
#include "logging.h"
#include "filter.h"
#include "det.h"

#include "engine.h"

#include "swc_control.h"

/* USER CODE END SWC_MONITOR_INCLUDE */


#include "sp_common.h"

/* USER CODE START SWC_MONITOR_USERDEFINITIONS */


//================================================================================================

//Filter functions to detect blocking wheels
FILTER_t MONITOR_flt_rl = {};
FILTER_t MONITOR_flt_rr = {};
FILTER_t MONITOR_flt_fl = {};
FILTER_t MONITOR_flt_fr = {};

//================================================================================================

typedef enum {
    MONITOR_allok,          /*!< All check report ok */
    MONITOR_safe_1,         /*!< Minor problems, slow down */
    MONITOR_safe_2,         /*!< Major problems, stop but repairable */
    MONITOR_safe_3,         /*!< Major problems, permanent stop for this power cycle */
} MONITOR_request_t;

/**
 * function pointer used for guards
 */
typedef MONITOR_request_t (*MONITOR_FctPtr_t)();

//================================================================================================

/**
 * Check if the connection state is IS_DRIVING. Only in this case, the engines will be activated
 **/
MONITOR_request_t MONITOR__checkConnectionState();

/**
 * Check if the remote control is active by checking the joystick signal age.
 **/
MONITOR_request_t MONITOR__checkRemote();

/**
 * Check if one or more engines block
 **/
MONITOR_request_t MONITOR__checkEngine();

/**
 * Check for collission
 **/
MONITOR_request_t MONITOR__checkColission();

//================================================================================================

const MONITOR_FctPtr_t MONITOR_ActiveCheck[] = {
    MONITOR__checkConnectionState,
    MONITOR__checkRemote,
    MONITOR__checkEngine,
    MONITOR__checkColission,
};

const uint16_t MONITOR_ActiveCheck_Size = sizeof(MONITOR_ActiveCheck)/sizeof(MONITOR_FctPtr_t);
    

/* USER CODE END SWC_MONITOR_USERDEFINITIONS */



/*
 * component: swc_monitor
 * cycletime: 10
 * description: Cyclic runnable checking the system health
 * events: 
 * name: MONITOR_health_run
 * shortname: health
 * signalIN: so_joystick|so_targetspeed|so_currentspeed|so_controlspeed|so_protocolRx|so_protocolTx|so_carState|so_eventIn|so_eventOut|so_carErrorState|so_ultrasonic
 * signalOUT: so_carErrorState
 * task: tsk_io
 */
void MONITOR_health_run(RTE_event ev){
	
	/* USER CODE START MONITOR_health_run */
    
    SC_CARERRORSTATE_data_t carErrorState = SC_CARERRORSTATE_INIT_DATA;
        
    //Run all checker functions and escalate problem report
    MONITOR_request_t checkResult = MONITOR_allok;
    
    for (uint16_t i = 0; i < MONITOR_ActiveCheck_Size; i++)
    {
        MONITOR_request_t localCheck = MONITOR_ActiveCheck[i]();
        if (localCheck > checkResult) checkResult = localCheck;
    }
    
    //Some simple handling
    if (MONITOR_allok == checkResult)
    {
        carErrorState.m_led = ERROR_LED_NONE;
        carErrorState.m_maxSpeed = 100;
    }
    else if (MONITOR_safe_1 == checkResult)
    {
        carErrorState.m_led = ERROR_LED_YELLOW;
        carErrorState.m_maxSpeed = 50;
    }        
    else  // Safe 2 oder Safe 3 - TODO create real state machine later
    {
        carErrorState.m_led = ERROR_LED_RED;
        carErrorState.m_maxSpeed = 0;
    }
    
    //Write to RTE and Driver
    RTE_SC_CARERRORSTATE_set(&SO_CARERRORSTATE_signal, carErrorState);
    RTE_SC_CARERRORSTATE_pushPort(&SO_CARERRORSTATE_signal);
    

    /* USER CODE END MONITOR_health_run */
}

/*
 * component: swc_monitor
 * cycletime: 0
 * description: Receive Diagnostic Request and processes it, e.g clears DETor transmits DET to client
 * events: ev_diagnosticrequest_onData
 * name: MONITOR_processDiagnosticRequest_run
 * shortname: processDiagnosticRequest
 * signalIN: so_diagnosticRequest
 * signalOUT: 
 * task: tsk_io
 */
void MONITOR_processDiagnosticRequest_run(RTE_event ev){
	
	/* USER CODE START MONITOR_processDiagnosticRequest_run */
    SC_DIAGNOSTICREQUEST_data_t command = RTE_SC_DIAGNOSTICREQUEST_get(&SO_DIAGNOSTICREQUEST_signal);
    
    switch (command)
    {
        case DET_ClearData   : DET_clear(&DET); break;
        case DET_RequestData : DET_dump(&DET); break;
        default: break;
    }
    /* USER CODE END MONITOR_processDiagnosticRequest_run */
}

/* USER CODE START SWC_MONITOR_FUNCTIONS */

/**
 * Check if the connection state is IS_DRIVING. Only in this case, the engines will be activated
 **/
MONITOR_request_t MONITOR__checkConnectionState()
{
    CONNECTION_state_t connectionState = (CONNECTION_state_t)STATE_getCurrentState(&CONTROL_ConnectionFSM);
    
    if (CONNECTIONSTATE_IS_DRIVING == connectionState)
    {
        return MONITOR_allok;
    }
    else
    {
        return MONITOR_safe_2;
    }
}

/**
 * Check if the remote control is active by checking the joystick signal age.
 **/
MONITOR_request_t MONITOR__checkRemote()
{
    uint32_t age = RTE_SC_JOYSTICK_getAge(&SO_JOYSTICK_signal);
    
    if (age > 3000) return MONITOR_safe_2;
    if (age > 500) return MONITOR_safe_1;
}

/**
 * Try and error
**/ 
#define MONITOR_DETECTBLOCKING  140

/**
 * Check if one or more engines block
 **/
MONITOR_request_t MONITOR__checkEngine()
{
    // This one is a bit more complex. We cannot simply check the delta, 
    // as in a braking or speeding up situation, this is the normal behaviour.
    // We need to integrate the error over time and check the accumulated error.
    
    SC_ENGINESPEED_data_t CONTROL_speed = RTE_SC_ENGINESPEED_get(&SO_CONTROLSPEED_signal);
    SC_ENGINESPEED_data_t CURRENT_speed = RTE_SC_ENGINESPEED_get(&SO_CURRENTSPEED_signal);

    float e_rl = 0;
    float e_rr = 0;
    float e_fl = 0;
    float e_fr = 0;
    
    //We directly access the engine as we are in a diagnostic module.
    //Not 100% elegant, but creating another signal just for this would be an overkill
    //We might consider adding the integral error to the engine signal, but as we have 2 signals (control and current), this might be a bit ambiguous
    ENG_readError_I(&ENG_FL, &e_fl);
    ENG_readError_I(&ENG_FR, &e_fr);
    ENG_readError_I(&ENG_RL, &e_rl);
    ENG_readError_I(&ENG_RR, &e_rr);
    
    //Todo: sometimes, the i_err still escalates - to be debugged further
    
    //LOG_I("MON_ENG_BLOCK", "RR CTRL %d CURR %d - err_i %d ", CONTROL_speed.m_rpm_rr, CURRENT_speed.m_rpm_rr, (int)e_rr);
    //LOG_I("MON_ENG_BLOCK", "RR err_i %d RL err_i %d FR err_i %d FL err_i %d ", (int)e_rr, (int)e_rl, (int)e_fr, (int)e_fl);
    //LOG_I("MON_ENG_BLOCK", "FR CTRL %d CURR %d - err_i %d ", CONTROL_speed.m_rpm_fr, CURRENT_speed.m_rpm_fr, (int)e_fr);
    
    //return MONITOR_allok;
    
    if (fabs(e_rl) > MONITOR_DETECTBLOCKING ||
        fabs(e_rr) > MONITOR_DETECTBLOCKING ||
        fabs(e_fl) > MONITOR_DETECTBLOCKING ||
        fabs(e_fr) > MONITOR_DETECTBLOCKING )
    {
        return MONITOR_safe_2;
    }
    else
    {
        return MONITOR_allok;
    }
}

/**
 * Check for collission
 **/
MONITOR_request_t MONITOR__checkColission()
{
    //Read in targetspeed and distance
    //Only the distance in the direction of movement is critical
    SC_CARSPEED_data_t targetsspeed = RTE_SC_CARSPEED_get(&SO_TARGETSPEED_signal);
    SC_ULTRASONICARRAY_data_t us = RTE_SC_ULTRASONICARRAY_get(&SO_ULTRASONIC_signal);
    
    MONITOR_request_t result = MONITOR_allok;
    
    //Speeds lower than 0.2m/s are not supervised
    //Warning Distance: 50cm
    //Stop DIstance: 20cm
    
    const float speedsupervision = 0.2;
    const uint16_t warn_distance = 50;
    const uint16_t stop_distance = 20;
    
    if (targetsspeed.m_vy > speedsupervision)
    {
        //Forward direction
        if (us.m_distance_front.m_distance < stop_distance) 
        {
            result =  MONITOR_safe_2;
        }
        else if (us.m_distance_front.m_distance < warn_distance) 
        {
            result = MONITOR_safe_1;
        }
    }
    else if (targetsspeed.m_vy < -speedsupervision)
    {
        //Reverse direction
        if (us.m_distance_rear.m_distance < stop_distance) 
        {
            result = MONITOR_safe_2;
        }
        else if (us.m_distance_rear.m_distance < warn_distance) 
        {
            result =  MONITOR_safe_1;
        }
    }
    else
    {
        //No check
    }

    return result;

    
}

/* USER CODE END SWC_MONITOR_FUNCTIONS */

